package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

const (
	n = 10
)

func main() {
	rand.Seed(time.Now().UnixNano()) //для разных рандомных значений при каждом запуске.
	var wg sync.WaitGroup            //инициируем группу ожидания.
	wg.Add(2)                        //увеличиваем счетчик группы ожидания.

	chX := make(chan int) //инициируем канал, в который будем писать данные из массива.

	go worker(chX, &wg)          //запускаем горутину умножающую числа на два.
	var counts [n]int            //инициируем массив.
	for idx, _ := range counts { //итерируемся по массиву.
		counts[idx] = rand.Intn(30) //присваем случайные значения в массиве.
		chX <- counts[idx]          //пишем в канал данные из массива.
	}
	close(chX) //закрываем канал вручную, чтобы разблокировались рабочие горутины.
	wg.Wait()  //ждем завершения рабочих горутин.
}

func worker(chx chan int, wg *sync.WaitGroup) {
	defer wg.Done()         //отложенно убавляем счетчик группы ожидания.
	chRes := make(chan int) //инициируем канал в который будем писать конечные результаты.
	defer close(chRes)      //отложенно закрываем канал.

	go printer(chRes, wg) //запускаем горутину, выводящую данные из второго канала на консоль.

	for value := range chx { //считываем данные из первого канала в цикле, чтение завершится с закрытием канала.
		res := value * 2
		chRes <- res //пишем данные вот второй канал.
	}
}

func printer(chRes chan int, wg *sync.WaitGroup) {
	defer wg.Done()            //отложенно убавляем счетчик группы ожидания.
	for value := range chRes { //считываем данные из второго канала в цикле, чтение завершится с закрытием канала.
		fmt.Println(value) //пишем данные в стандартный поток вывода.
	}
}
