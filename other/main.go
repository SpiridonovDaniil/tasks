package main

//2.Интерфейсы.
//Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.
//Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
//Будучи архитектурным инструментом, интерфейсы помогают отвязывать части вашей кодовой базы.

//3.RWMutex.
//Go предлагает другой тип мьютекса, называемый sync.RWMutex, который позволяет нескольким читателям удерживать блокировку,
//но только одному писателю. используются для блокировки и разблокировки для целей чтения.
//Блокировка и разблокировка sync.RWMutex для эксклюзивной записи должны выполняться с помощью Lock() и Unlock() соответственно.
//
//Это означает, что либо один писатель может удерживать блокировку, либо несколько считывателей, но не то и другое одновременно!
//Вы, скорее всего, будете использовать такой мьютекс, когда большинство горутин хотят прочитать переменную, и вы не хотите, чтобы горутины ждали, чтобы получить эксклюзивную блокировку.

//4.Отличия буферизированных каналов от небуферизированных.
//

//5.struct{}{} весит 0

//6. нет, Диспетчеризация методов упрощается, если не требуется выполнять сопоставление типов.  Предлагается просто давать разные имена методам и функциям.
// Как аналог можно использовать интерфейсы.
//type Slice interface {
//	Len() int
//	Get(int) interface{}
//}
//
//Search(slice Slice, x interface{}) bool
//
//
//Теперь достаточно создать два типа:
//
//type Ints []int
//type Strings []string
//
//
//И реализовать интерфейс в каждом из типов. После этого можно использовать поиск и по строкам и по числам:
//
//var strings Strings = []string{"one", "two", "three"}
//fmt.Println(Search(strings, "one")) // true
//fmt.Println(Search(strings, "four")) // false
//
//var ints Ints = []int{0, 1, 2, 3, 4, 5}
//fmt.Println(Search(ints, 0)) // true
//fmt.Println(Search(ints, 10)) // false

//7. в случайной.
//// decide where to start
//r := uintptr(fastrand())
//вот часть кода из исходного кода рантайма языка. как видим место поиска определяется рандомно!

//Попытка получить значение карты с ключом, которого нет на карте, вернет нулевое значение для типа записей на карте.

// Поле buckets — хранилище пар ключ-значение, таких «ведер» несколько, в каждом лежит 8 пар. Сначала в «ведре» лежат слоты для дополнительных битов хэшей (e0..e7 названо e — потому что extra hash bits). Далее лежат ключи и значения как сначала список всех ключей, потом список всех значений.
//
//По хэш функции определяется в какое «ведро» мы кладем значение, внутри каждого «ведра» может лежать до 8 коллизий, в конце каждого «ведра» есть указатель на дополнительное, если вдруг предыдущее переполнилось.
//
//Как растет map?
//
//В исходном коде можно найти строчку:
// Maximum average load of a bucket that triggers growth is 6.5.
//
//то есть, если в каждом «ведре» в среднем более 6,5 элементов, происходит увеличение массива buckets.
//При этом выделяется массив в 2 раза больше, а старые данные копируются в него маленькими порциями каждые вставку или удаление, чтобы не создавать очень крупные задержки.
//Поэтому все операции будут чуть медленнее в процессе эвакуации данных (при поиске тоже, нам же приходится искать в двух местах).
//После успешной эвакуации начинают использоваться новые данные.

//8.
//Функции 'new' и 'make' различаются тем, что: 'new' возвращает указатель вместо значения возвращаемое функцией 'make'.
//'make' имеет вариадический аргумент 'size'. 'make' выделяет память и инциализирует только объекты типов: slice, map, or chan.

//9. Сколько существует способов задать переменную типа slice или map?
//Хэш таблица в языке go представлена ключевым словом map и может быть объявлена одним из способов ниже (подробнее о них позже):
//
// m := make(map[key_type]value_type)	+
// m := new(map[key_type]value_type) -
// var m map[key_type]value_type	-
// m := map[key_type]value_type{key1: val1, key2: val2}	+

//new и var бессмысленно, так как При попытке запуска такой программы получим панику и сообщение «assignment to entry in nil map».
//А все потому что мапа — ссылочный тип и мало объявить переменную, надо ее проинициализировать:
// карта в го это указатель на структуру:
//// A header for a Go map.
//type hmap struct {
//	// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
//	// Make sure this stays in sync with the compiler's definition.
//	count     int // # live cells == size of map.  Must be first (used by len() builtin)
//	flags     uint8
//	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
//	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
//	hash0     uint32 // hash seed
//
//	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
//	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
//	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)
//
//	extra *mapextra // optional fields
//}
//
//Слайс также указательный тип данных, поэтому для него подходят те-же методы, что и для карты.

//10.
// 1
// 1

//func update(p *int) {
//	b := 2
//	p = &b	не работает, так как в функцию не передан указатель на переменную р.
//}
//func main() {
//	var (
//		a = 1
//		p = &a		//присваиваем указатель переменной а.
//	)
//	fmt.Println(*p) //разыменовываем указатель (1).
//	update(p)		//передаем переменную значение которой указать на переменную а.
//	fmt.Println(*p)
//}

// 11.
//4 0 1 2 3 deadlock

//func main() {
//	wg := sync.WaitGroup{}
//	for i := 0; i < 5; i++ {					//дедлок произошел из-за того, что группа ожидания передана не по указателю.
//		wg.Add(1)								//то есть была создана копия группы ожидания, следовательно и счетчик вычитался в копии.
//		go func(wg sync.WaitGroup, i int) {		//поэтому главная горутина уснула на всегда.
//			fmt.Println(i)
//			wg.Done()
//		}(wg, i)
//	}
//	wg.Wait()
//	fmt.Println("exit")
//}

// 12.
// 0
//func main() {
//	n := 0
//	if true {
//		n := 1			//в данном случае в области памяти условия была создана новая переменная, поэтому значение переменной n не изменилось.
//		n++
//	}
//	fmt.Println(n)
//}

// 13.
// [100 2 3 4 5]
//func someAction(v *[]int8, b int8) { //слайс передан по значению, но в структуре слайса помимо длины и емкости есть указатель на массив
//	(*v)[0] = 100					   //поэтому когда мы пытаемся изменить элемент в массиве, то меняем все получается, так как мы идем к определенному указателем
//	*v = append(*v, b)				   //участку памяти, а вот когда добавляем элемент, то длина и емкость не изменяются(копии).
//}
//func main() {
//	var a = []int8{1, 2, 3, 4, 5}
//	someAction(&a, 6)
//	fmt.Println(a)
//}

// 14.
// [b b a][a a]
//func main() {
//	slice := []string{"a", "a"}
//	func(slice []string) {
//		fmt.Println(cap(slice))
//		slice = append(slice, "a") 		  //причина: копия длины и емкости
//		fmt.Println(cap(slice))
//		slice[0] = "b" 					  //причина: эвакуация данных, после добавления элемента, в структуре слайса
//		slice[1] = "b"					  //изменился указатель на массив.
//		fmt.Print(slice)
//	}(slice)
//	fmt.Print(slice)
//}
