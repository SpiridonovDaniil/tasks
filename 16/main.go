package main

import (
	"fmt"
	"sort"
)

func main() {
	m := [10]int{1224, 322, 85, 67, 95, 1, 98, 501, 33, 79}
	sli := m[:] //чтобы выполнить условие и отсортировать сам массив, создаем слайс, указывающий на область памяти значений массива.
	sort.Ints(sli)
	fmt.Println(m)

	strm := [6]string{"Lora", "John", "Billy", "Charlie", "Groot", "Alice"}
	slis := strm[:]
	sort.Strings(slis)
	fmt.Println(strm)

	flm := [10]float64{122.5, 32.2, 8.6, 6.7, 9.5, 1, 9.8, 50.1, 3.3, 7.9}
	slfl := flm[:]
	sort.Float64s(slfl)
	fmt.Println(flm)

	sm := [10]int{12, 22, 5, 7, 695, 2, 28, 5, 43, 9}
	ssli := sm[:]
	sort.Ints(ssli)
	fmt.Println(sm)
	//Встроенные методы sort.Ints, sort.Strings, sort.Float64s и sort.Slice используют в своей основе быструю сортировку. Основная неявная проблема
	//данных методов в том, что они не гарантируют стабильность данных, что проявляется в том,
	//что равные элементы могут быть поменяны местами.
	//Быстрая сортировка основана на условном раздвоении массива на 2 массива по поворотному элементу(обычно центральный),
	//где все элементы левой части массива должны быть меньше поворотного элемента, а все элементы правой части больше
	//поворотного элемента.
}
